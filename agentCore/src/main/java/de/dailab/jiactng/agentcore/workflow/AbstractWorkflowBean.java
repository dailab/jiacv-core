package de.dailab.jiactng.agentcore.workflow;

import java.io.Serializable;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import org.sercho.masp.space.event.SpaceEvent;
import org.sercho.masp.space.event.SpaceObserver;
import org.sercho.masp.space.event.WriteCallEvent;

import de.dailab.jiactng.agentcore.action.AbstractMethodExposingBean;
import de.dailab.jiactng.agentcore.action.Action;
import de.dailab.jiactng.agentcore.action.ActionResult;
import de.dailab.jiactng.agentcore.comm.CommunicationAddressFactory;
import de.dailab.jiactng.agentcore.comm.ICommunicationAddress;
import de.dailab.jiactng.agentcore.comm.ICommunicationBean;
import de.dailab.jiactng.agentcore.comm.IGroupAddress;
import de.dailab.jiactng.agentcore.comm.message.IJiacMessage;
import de.dailab.jiactng.agentcore.comm.message.JiacMessage;
import de.dailab.jiactng.agentcore.knowledge.IFact;
import de.dailab.jiactng.agentcore.ontology.IActionDescription;

/**
 * Used for AgentBeans generated by the VSDT's BPMN-to-AgentBeans Transformation,
 * but can just as well be used as a super class for any other JIAC agent bean.
 * It provides some useful helper methods and some simple "event handler" 
 * mechanisms.
 * 
 * This class should be the super class of generated workflow based agent bean.
 * It provides send and receive Method and the Actions needed for communication,
 * so the actual generated code can be kept compact and clean.
 * It also defines a number of Helper classes, particularly for Event Handling.
 * 
 * @author pstan, kuester
 */
public abstract class AbstractWorkflowBean extends AbstractMethodExposingBean {
	
	/*
	 * COMMONLY USED ACTIONS
	 */
	
	protected Action sendAction;
	protected Action joinAction;
	protected Action leaveAction;
	
	@Override
	public void doStart() throws Exception {
		super.doStart();
		
		// retrieve communication actions
		sendAction = retrieveAction(ICommunicationBean.ACTION_SEND);
		joinAction = retrieveAction(ICommunicationBean.ACTION_JOIN_GROUP);
		leaveAction = retrieveAction(ICommunicationBean.ACTION_LEAVE_GROUP);
		
		if (sendAction == null) log.warn("Could not find Send Action");
		if (joinAction == null) log.warn("Could not find Join Action");
		if (leaveAction == null) log.warn("Could not find Leave Action");
	}
	
	/*
	 * CONVENIENCE METHOD TO IMPROVE READABILITY OF GENERATED CODE
	 */

	/**
	 * Find and invoke an action, or throw a runtime exception of that action 
	 * could not be found.
	 * 
	 * The result handling could maybe also be moved here, but this is tricky, 
	 * since the service could have multiple return values.
	 * 
	 * @param actionName	the name of the action to invoke
	 * @param parameters	the parameters
	 * @return				actionResult, for further processing
	 */
	protected ActionResult findAndInvoke(String actionName, Serializable[] parameters) {
		IActionDescription action = thisAgent.searchAction(new Action(actionName));
		if (action == null) {
			throw new RuntimeException("Action " + actionName + " not found!");
		}
		return invokeAndWaitForResult(action, parameters);
	}
	
	/**
	 * Join multi-cast message group.
	 * 
	 * @param groupName		name of the group to join
	 */
	protected void join(String groupName) {
		IGroupAddress groupAddress = CommunicationAddressFactory.createGroupAddress(groupName);
		invoke(joinAction, new Serializable[] {groupAddress});
	}
	
	/**
	 * Leave multi-cast message group.
	 * 
	 * @param groupName		name of the group to leave
	 */
	protected void leave(String groupName) {
		IGroupAddress groupAddress = CommunicationAddressFactory.createGroupAddress(groupName);
		invoke(leaveAction, new Serializable[] {groupAddress});
	}
	
	/**
	 * Send JiacMessage to multi-cast group.
	 * 
	 * @param payload		payload of the message
	 * @param address		name of the multi-cast group or agent message box
	 * @param isGroup		whether the address is a multi-cast group
	 */
	protected void send(IFact payload, String address, boolean isGroup) {
		IJiacMessage message = new JiacMessage(payload);
		ICommunicationAddress comAddress = isGroup ? CommunicationAddressFactory.createGroupAddress(address)
				: CommunicationAddressFactory.createMessageBoxAddress(address);
		invoke(sendAction, new Serializable[] {message, comAddress});
	}
	
	/**
	 * Receive message from multi-cast group.
	 * 
	 * @param payloadClass	expected payload type
	 * @param groupName		name of the multi-cast group, or null
	 * @return				payload of the message
	 */
	@Deprecated
	protected IFact receive(Class<?> payloadClass, String groupName, long timeout) {
		IJiacMessage message = receiveMessage(payloadClass, groupName, timeout);
		if (message != null) {
			return message.getPayload();
		}
		return null;
	}
	
	protected IJiacMessage receiveMessage(Class<?> payloadClass, String groupName, long timeout) {
		long start = System.currentTimeMillis();
		while (timeout <= 0 || System.currentTimeMillis() - start < timeout) {
			if (checkInterrupted()) return null;
			for (JiacMessage msg : memory.readAll(new JiacMessage())) {
				// check payload
				if ((payloadClass == null || payloadClass.isInstance(msg.getPayload()))) {
					// check group address, if any
					if (groupName == null || msg.getHeader(IJiacMessage.Header.SEND_TO).equalsIgnoreCase(groupName)) {
						memory.remove(msg);
						return msg;
					}
				}
			}
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				log.debug("Receive interrupted");
				Thread.currentThread().interrupt();
			}
		}
		return null;
	}
	
	
	/*
	 * HELPER CLASSES, E.G. EVENT HANDLER
	 */

	/**
	 * Check whether the current thread has been interrupted by an event handler.
	 * This method should be called at the start of each activity and at the
	 * beginning of each loop, aborting the activity if the thread is interrupted.
	 * 
	 * @return		whether the current thread is interrupted
	 */
	protected boolean checkInterrupted() {
		if (Thread.currentThread().isInterrupted()) {
			log.debug(Thread.currentThread().getName() + " interrupted");
			return true;
		}
		return false;
	}
	
	/**
	 * Abstract super class for all Event Handler classes.
	 */
	protected abstract class EventHandler extends Thread {
		
		protected final Thread toStop;
		protected boolean triggered = false;
		
		public EventHandler(Thread toStop) {
			this.toStop = toStop;
		}
			
		public void stopEventHandler() {
			this.interrupt();
		}
		
		protected void setTriggered() {
			this.triggered = true;
			toStop.interrupt();
		}
		
		public boolean isTriggered() {
			return triggered;
		}
		
	}
	
	
	/**
	 *  Inner class that handles timeout events
	 */
	protected class TimeoutEventHandler extends EventHandler {
		
		protected long timeout;
		
		public TimeoutEventHandler(Thread toStop, long timeout) {
			super(toStop);
			this.timeout = timeout;
		}
		
		public void run() {
			try {
				Thread.sleep(timeout);
				setTriggered();
			} catch (InterruptedException e ) {
				log.debug("Timeout interrupted");
			}
		}
		
	}
	
	
	/**
	 *  Inner class that handles time events
	 */
	protected class TimeEventHandler extends TimeoutEventHandler {
		
		public TimeEventHandler(Thread toStop, String timeExpression) {
			super(toStop, 0);
			try {
				long whenToStop = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").parse(timeExpression).getTime();
				this.timeout = whenToStop - System.currentTimeMillis();
			} catch (ParseException e) {
				log.error("ParseException: Time Expression has to be in yyyy-MM-dd'T'HH:mm:ss.SSSZ format, but was " + timeExpression);
			} 
		}
	}
	
	
	/**
	 * Inner class that handles rule events
	 */
	protected abstract class RuleEventHandler extends EventHandler {
		
		public RuleEventHandler(Thread toStop) {
			super(toStop);
		}
		
		public void run() {
			try {
				while (! checkRule()) {
					Thread.sleep(500);
				}
				setTriggered();
			} catch (InterruptedException e ) {
				log.debug("Rule checking interrupted");
			}
		}

		public abstract boolean checkRule();
	}
	
	
	/**
	 *  Inner class that handles message events
	 */
	protected class MessageEventHandler extends EventHandler implements SpaceObserver<IFact> {
		private static final long serialVersionUID = -6952371209533652499L;

		protected IGroupAddress groupAddress;
		protected Class<?> payloadClass;
		protected IFact received = null;
		
		public MessageEventHandler(Thread toStop, String channel, Class<?> payloadType) {
			super(toStop);
			this.groupAddress = channel != null ? CommunicationAddressFactory.createGroupAddress(channel) : null;
			this.payloadClass = payloadType;
		}
		
		public void run() {
			memory.attach(this, new JiacMessage());
			if (groupAddress != null) {
				invoke(joinAction, new Serializable[] {groupAddress});
			}
			
			// FIXME memory observer seems not to work properly...
			// works fine for receiving the initial message, though...
			while (! isInterrupted()) {
//				System.out.println("checking...");
				for (JiacMessage msg : memory.readAll(new JiacMessage())) {
					// check payload
					if ((payloadClass == null || payloadClass.isInstance(msg.getPayload()))) {
						// check group address, if any
						if (groupAddress == null || msg.getHeader(IJiacMessage.Header.SEND_TO).equalsIgnoreCase(groupAddress.getName())) {
							memory.remove(msg);
							received = msg.getPayload();
							setTriggered();
						}
					}
				}
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					log.debug("Receive interrupted");
					Thread.currentThread().interrupt();
				}
			}
		}
		
		public void notify(SpaceEvent<? extends IFact> event) {
			if (event instanceof WriteCallEvent<?>) {
				WriteCallEvent<?> wce = ((WriteCallEvent<?>) event);
				if (wce.getObject() instanceof IJiacMessage) {
					IJiacMessage msg= (IJiacMessage) wce.getObject();
					
					if ((payloadClass == null || payloadClass.isInstance(msg.getPayload())) && 
							(groupAddress == null || msg.getHeader(IJiacMessage.Header.SEND_TO).
														equalsIgnoreCase(groupAddress.getName()))) {
						memory.remove(msg);
						received = msg.getPayload();
						setTriggered();
					}
				}
			}
		}

		@Override
		public void stopEventHandler() {
			super.stopEventHandler();
			memory.detach(this);
//			invoke(leaveAction, new Serializable[]{groupAddress});
		}
		
		public Object getReceived() {
			return received;
		}
		
	}
	
}
