<?xml version="1.0"?>
<faqs xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://maven.apache.org/maven-1.x/plugins/faq/faq.xsd" title="Frequently Asked Questions" toplink="false">
    <part id="general">
        <title>General</title>
        <faq id="whats-agentCore">
            <question>What is agentCore?</question>
            <answer>
                <p>It provides basic building blocks for JIAC TNG, eg. agent life-cycle, etc.
                </p>
            </answer>
        </faq>
    </part>
    <part id="how-to">
        <title>How to use agentCore</title>
        <faq id="how-use">
            <question>How do I use agentCore?</question>
            <answer>
                <p>I just do not know.</p>
            </answer>
        </faq>
    </part>
    <part id="lifecycle">
        <title>Lifecycle</title>
        <faq id="lifecycle1">
            <question>What are the available phases in the lifecycle model?</question>
            <answer>
                <p>
                  Basically, there are 3 distinct states a component may have:
                  VOID, READY and STARTED. Being VOID means being either UNDEFINED
                  or CLEANED_UP, whereas READY means INITIALIZED or STOPPED.
                  STARTED means the active state of the <code>ILifecycle</code> instance.
                  Check out the lifecycle graph from some project documentation
                  to learn more about the lifecycle model.
                </p>
            </answer>
          </faq>
          <faq id="lifecycle2">
            <question>How does the Lifecycle API apply to my code?</question>
            <answer><p>
              The <code>de.dailab.jiactng.agentcore.lifecycle</code> package contains
              the <code>ILifecycle</code> interface as well as all necessary code.
              You may subclass <code>AbstractLifecycle</code> or implement
              <code>ILifecycle</code> to introduce lifecycle management into your
              code. In the latter case check out how <code>AbstractLifecycle</code>
              employs the <code>DefaultLifecycleHandler</code> class.</p>
            </answer>
          </faq>
          <faq id="lifecycle3">
            <question>What is the difference between loose and strict lifecycle?</question>
            <answer><p>
              Loose means that there are no restrictions on transitions between
              lifecycle states. The strict mode requires you to adhere to the lifecycle graph.
              <code>DefaultLifecycleHandler</code> offers a constructor that accepts
              a boolean parameter, indicating wether or not you want the lifecycle
              handler to operate in strict mode. The default is loose handling.</p>
            </answer>
          </faq>
          <faq id="lifecycle4">
            <question>Can I switch arbitrarily between those lifecycle states?</question>
            <answer><p>
              In loose mode you can. In strict mode you can switch only between
              adjacent lifecycle states.</p>
            </answer>
          </faq>
          <faq id="lifecycle5">
            <question>How do the lifecycle events come into play?</question>
            <answer><p>
              You can register a <code>ILifecycleListener</code> with any <code>
              Lifecycle</code> to receive state change events. This is different from
              the JMX state change notifications.</p>
            </answer>
          </faq>
          <faq id="lifecycle6">
            <question>Can I create a hierarchy of lifecycle listeners?</question>
            <answer><p>
              Yes. Suppose, there is a lifecycle listener that manages a number
              of lifecycle objects that make use of the <code>DefaultLifecycleHandler</code>.
              One of them, which is not a lifecycle listener itself, is managing a bunch of
              lifecycles as well. To have the top-level object receiving lifecycle events from
              below, you call <code>createLifecycleListener()</code> on their parent object's lifecycle handler
              and add it to them. Now all lifecycle events are propagated directly to the top-level object.</p>
            </answer>
        </faq>
    </part>
    <part id="Agent">
	    <title>Agents</title>
          <faq id="faq1_Agent">
            <question>How do I create my own Agent?</question>
            <answer>
            	..
            </answer>
          </faq>
          <faq id="faq2_Agent">
            <question>How are Agents and Lifecycles related ?</question>
            <answer>
            	..
            </answer>
          </faq>          
          <faq id="faq3_Agent">
            <question>Does an Agent has to have a lifecycle? If it has to, do I have to implement it by myself ?</question>
            <answer>
            	..
            </answer>
          </faq>	    
          <faq id="faq4_Agent">
            <question>What kind of and how much ressources does one agent require ? Is it advisable to keep the number of Agents for my application low ?</question>
            <answer>
            	..
            </answer>
          </faq>
          <faq id="faq5_Agent">
            <question>How do I let the Agents do what I want ?</question>
            <answer>
            	..
            </answer>
          </faq>  
          <faq id="faq6_Agent">            
            <question>Is there a 'Hello World' Agent ? Where ?</question>
            <answer>
            	..
            </answer> 
          </faq>
          <faq id="faq7_Agent">            
            <question>Is there a more complex example of Agents ? Where ?</question>
            <answer>
            	..
            </answer> 
          </faq>
          
    </part>
    <part id="management">
        <title>Monitoring and Control</title>
        <faq id="how-manage">
            <question>How do I manage a running application?</question>
            <answer><p>
                Applications implemented with JIAC TNG use JMX (Java Management Extensions,
                http://java.sun.com/j2se/1.5.0/docs/guide/jmx/) to provide management functionality 
                of agents and agent nodes for remote monitoring and control on condition that the
                application was started with system property <code>com.sun.management.jmxremote</code>
                (see example "HelloWorld"). While a special tool does not yet exist, humans may start
                the tool "jconsole" of JDK1.5+ (Java Development Kit, version 1.5 or higher) on the 
                host where the application runs, connect to the JVM (Java Virtual Machine) of the
                application, change to the tab "MBeans" and open the tree under domain
                <code>de.dailab.jiactng.agentcore</code>. For each element you can read its attributes,
                invoke operations on it and subscribe for notifications. Instead of managing the 
                application manually with tools you may also implement your own Java program which
                manages your application automatically by using the JMX API. If your program runs in
                the same JVM as the application you don't need to integrate a connector but you need
                to set the system property <code>jmx.invoke.getters</code> (see test cases
                "AgentMBeanTest" and "SimpleAgentNodeMBeanTest"). Otherwise you have to set the property
                <code>jmxConnectors</code> of the agent node with the protocols of the JMX connectors 
                to be used (see example "HelloWorld") and to integrate a connector client into your 
                program. Connector servers not yet registered by using any kind of discovery mechanisms, 
                so existing servers can not be looked up automatically at the moment.</p>
            </answer>
        </faq>
    </part>
</faqs>
